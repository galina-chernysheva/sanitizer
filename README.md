Валидация типов значений JSON данных
===============================

PHP 7.1


## Структура проекта:

0. Папка controllers:
содержит единственный контроллер - ValidationController, отвечающий за приём данных из POST запроса и выдачу результатов обработки данных.

1. Папка utils:
содержит непосредственно класс санитайзера-валидатора -  JsonSchemaValidator (/utils/validators) и вспомогательные классы (санитайзеры-валидаторы отдельных типов данных (/utils/types), классы исключений (/utils/exceptions)).

2. Папка tests:
содержит наборы тестов и тестовые данные для проверки функциональности валидаторов и контроллера.

3. Папка vhost:
содержит конфиг хоста (необходимо настроить для тестов контроллера - hosts, include конфига в nginx.conf).

4. autoload.php:
скрипт загрузки классов, содержит проектную константу.

5. index.php:
скрипт - входная точка для всех запросов к хосту. Для тестовых целей задаёт данные для контроллера.

6. runTests.php:
скрипт для запуска тестов из папки tests.


## Как работает:
Валидация данных запроса разделена на несколько уровней "ответственности". 
Принимает запрос и вытаскивает данные из него контроллер. Далее он делегирует проверку данных санитайзеру. Для этого, помимо данных из запроса, необходимо задать схему, которая описывает типы значений в данных. Для этих целей используется стандарт JSON-Schema. Данные описываются в виде древовидной структуры с указанием типа "type" и возможных значений элементов, если значение является массивом или объектом. Схема так же json-encoded.
Есть базовые типы: 
* "integer" (целое число); 
* "float" (вещественное число); 
* "string" (строка); 
* "array" (индексированный массив, список);
* "object" (ассоциативный массив, объект). 

Базовые типы могут быть расширены кастомными. Например, введён кастомный тип "phone" (телефонный номер РФ) (унаследован от "string"). 
Массив вида ['\<type name\>' => \<type class\>, ..] необходимо передать в метод контроллера, если требуется поддержка кастомных типов при валидации схемы. В противном случае возникнет ошибка о неподдерживаемом типе данных в процессе проверки данных. Валидацию базовых типов можно переопределить, если задать новый кастомный тип с тем же \<type name\>.
Валидатор схемы проверяет её целостность, а проверку типов конкретных значений делегирует отдельным классам - валидаторам типов.

Результатом работы валидатора типа является сконвертированное значение или исключение; JsonSchemaValidator - массив с ошибками и сконвертированными данными или исключение; контроллера - json-encoded результат работы валидатора схемы и установка статуса ответа (500 - исключение валидатора схемы, 200 - данные получены).

Возможности:
* null, пустые массив и объект являются корректными значениями;
* можно задавать скалярные значения данных, например: 
данные - "+7 (900) 111 22 33", схема - '{ "type": "phone" }';
* тип элементов массива можно задать следующим образом: '{ "type": "array", "items": { "type": "integer" } }' - массив целых чисел;
* тип значений свойств объекта (ключей ассоциативного массива) можно задать следующим образом: '{ "type": "object", "properties": { "prop1": { "type": "float" }, "prop2": { "type": "string" } } }' - ассоциативный массив с ключами "prop1" и "prop2", значения которых соответствуют типам вещественное число и строка соответственно;
* если при типе "array" не указан тип элементов "items", то значение пройдёт только проверку на принадлежность к типу массив, проверка элементов будет пропущена;
* если при типе "object" не указан состав ключей и их типы "properties", то пройдёт только проверка на то, что значение является объектом. Если при этом указан тип элементов "items", то будет осуществлена проверка всех свойств объекта на соответствие указанному типу. В противном случае никаких дополнительных проверок не последует;
* при проверке объекта с указанными "properties" проверяется наличие перечисленных свойств (если не найдено - ошибка), "лишние" свойства не проверяются и исключений не генерируют;
* для типа "object" при указанных "properties" и "items" приоритет имеет "items", как более жёсткое ограничение типа (или наоборот - мягкое?.. как посмотреть :)). Совместно применяться и те, и другие пока не умеют;
* при проверке номера телефона из строки удаляется пунктуация, пробельные символы и знак +, после чего проверяется соответствие допустимому формату. Поэтому даже значение " ++ 7 ((900)) -- 111 --22 ..; 33" будет считаться корректным и после обработки преобразуется в "79001112233";
* список ошибок плоский, в тексте ошибки фигурирует имя параметра: например, сообщение 'obj[prop1][0]: Value is not integer' означает, что первое значение в массиве prop1 объекта obj не является целым числом.


## Что можно доделать:
* поддержку "одновременных" "items" и "properties" в объекте. Например, проверить все указанные "properties", а для оставшихся применять проверку по типу, указанному в "items";
* поддержку целых чисел, заданных в двоичном, восьмеричном и щестнадцатеричном форматах.
 